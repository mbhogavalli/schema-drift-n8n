{
  "name": "Schema Drift Detection & Evolution Demo",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "schema-drift/ingest",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook: Ingest Flight Data",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "schema-drift-ingest"
    },
    {
      "parameters": {
        "jsCode": "// Initialize schemas and database on first run\n// Fix: Check if staticData exists before accessing\n\nif (typeof $workflow === 'undefined' || !$workflow.staticData) {\n  $workflow = { staticData: {} };\n}\n\nif (!$workflow.staticData.db) {\n  $workflow.staticData.db = {\n    staging: { flights_raw: [] },\n    gold: { flights_pricing_v1: [], flights_pricing_v2: [] },\n    ops: { quarantine: [] },\n    featureFlags: { flights_pricing_read_compat: false },\n    compatView: null,\n    initialized: true\n  };\n}\n\nconst db = $workflow.staticData.db;\n\n// Extract incoming flight data from webhook\nconst incomingData = $input.item.json.body || $input.item.json;\n\n// Handle both single record and array of records\nlet flightRecords = [];\nif (Array.isArray(incomingData)) {\n  flightRecords = incomingData;\n} else if (incomingData.flight_id) {\n  flightRecords = [incomingData];\n} else if (incomingData.records && Array.isArray(incomingData.records)) {\n  flightRecords = incomingData.records;\n} else {\n  // If no valid data structure, return error\n  return {\n    json: {\n      error: true,\n      message: 'Invalid data format. Expected flight record(s) with flight_id field.',\n      received: incomingData\n    }\n  };\n}\n\nreturn {\n  json: {\n    records: flightRecords,\n    record_count: flightRecords.length,\n    timestamp: new Date().toISOString(),\n    db_initialized: db.initialized || false,\n    db_state: {\n      staging_count: db.staging.flights_raw.length,\n      gold_v1_count: db.gold.flights_pricing_v1.length,\n      quarantine_count: db.ops.quarantine.length\n    }\n  }\n};"
      },
      "id": "initialize-and-parse",
      "name": "Initialize & Parse Incoming Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// v1 Schema Contract Validation (Pandera-like)\n// Fix: Ensure staticData.db exists before accessing\n\nif (typeof $workflow === 'undefined' || !$workflow.staticData) {\n  $workflow = { staticData: {} };\n}\n\nif (!$workflow.staticData.db) {\n  $workflow.staticData.db = {\n    staging: { flights_raw: [] },\n    gold: { flights_pricing_v1: [], flights_pricing_v2: [] },\n    ops: { quarantine: [] },\n    featureFlags: { flights_pricing_read_compat: false },\n    compatView: null,\n    initialized: true\n  };\n}\n\nconst db = $workflow.staticData.db;\nconst records = $input.item.json.records || [];\n\n// v1 Schema Contract Validation Function\nfunction validateV1(record) {\n  const errors = [];\n  const driftDetected = { additiveColumns: [], typeErrors: [] };\n  \n  // flight_id: string, min 3 chars\n  if (!record.flight_id || typeof record.flight_id !== 'string' || record.flight_id.length < 3) {\n    errors.push('flight_id: must be string with min 3 characters');\n  }\n  \n  // origin: string, exactly 3 chars\n  if (!record.origin || typeof record.origin !== 'string' || record.origin.length !== 3) {\n    errors.push('origin: must be exactly 3 characters');\n  }\n  \n  // destination: string, exactly 3 chars\n  if (!record.destination || typeof record.destination !== 'string' || record.destination.length !== 3) {\n    errors.push('destination: must be exactly 3 characters');\n  }\n  \n  // depart_ts: valid timestamp\n  if (!record.depart_ts || isNaN(new Date(record.depart_ts).getTime())) {\n    errors.push('depart_ts: must be valid timestamp');\n  }\n  \n  // cabin: enum\n  const validCabins = ['ECONOMY', 'PREMIUM', 'BUSINESS', 'FIRST'];\n  if (!validCabins.includes(record.cabin)) {\n    errors.push(`cabin: must be one of ${validCabins.join(', ')}`);\n  }\n  \n  // fare_usd: number >= 0\n  if (typeof record.fare_usd !== 'number' || record.fare_usd < 0) {\n    if (typeof record.fare_usd === 'string') {\n      driftDetected.typeErrors.push('fare_usd: expected number, got string');\n    }\n    errors.push('fare_usd: must be number >= 0');\n  }\n  \n  // carrier_code: string, 2-3 chars\n  if (!record.carrier_code || typeof record.carrier_code !== 'string' || record.carrier_code.length < 2 || record.carrier_code.length > 3) {\n    errors.push('carrier_code: must be string with 2-3 characters');\n  }\n  \n  // currency: enum\n  const validCurrencies = ['USD', 'EUR', 'GBP'];\n  if (!validCurrencies.includes(record.currency)) {\n    errors.push(`currency: must be one of ${validCurrencies.join(', ')}`);\n  }\n  \n  // taxes_usd: number >= 0, nullable\n  if (record.taxes_usd !== null && record.taxes_usd !== undefined) {\n    if (typeof record.taxes_usd !== 'number' || record.taxes_usd < 0) {\n      errors.push('taxes_usd: must be number >= 0 or null');\n    }\n  }\n  \n  // Check for additive columns (not in v1 schema)\n  const v1Fields = ['flight_id', 'origin', 'destination', 'depart_ts', 'cabin', 'fare_usd', 'carrier_code', 'currency', 'taxes_usd'];\n  for (const key in record) {\n    if (!v1Fields.includes(key)) {\n      driftDetected.additiveColumns.push(key);\n    }\n  }\n  \n  return { errors, driftDetected };\n}\n\n// Process each record\nconst results = [];\n\nfor (const record of records) {\n  const corrId = `corr-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  const ts = new Date().toISOString();\n  \n  const { errors, driftDetected } = validateV1(record);\n  const hasDrift = driftDetected.additiveColumns.length > 0 || driftDetected.typeErrors.length > 0;\n  \n  // Always store raw payload\n  db.staging.flights_raw.push({\n    correlation_id: corrId,\n    received_at: ts,\n    payload_json: JSON.stringify(record)\n  });\n  \n  if (errors.length === 0 && !hasDrift) {\n    // âœ… SUCCESS: Insert into gold\n    db.gold.flights_pricing_v1.push({\n      ...record,\n      correlation_id: corrId,\n      received_at: ts\n    });\n    \n    results.push({\n      correlation_id: corrId,\n      record: record,\n      validation_result: 'PASSED',\n      action: 'Inserted into gold.flights_pricing_v1',\n      timestamp: ts\n    });\n  } else {\n    // ðŸ›‘ QUARANTINE: Schema drift or validation failure\n    const reason = errors.length > 0 \n      ? errors.join('; ') \n      : `Schema drift detected: ${driftDetected.additiveColumns.length > 0 ? 'additive columns: ' + driftDetected.additiveColumns.join(', ') : ''}${driftDetected.typeErrors.length > 0 ? ' type errors: ' + driftDetected.typeErrors.join(', ') : ''}`;\n    \n    db.ops.quarantine.push({\n      correlation_id: corrId,\n      received_at: ts,\n      reason: reason,\n      sample: JSON.stringify(record),\n      drift_detected: hasDrift\n    });\n    \n    results.push({\n      correlation_id: corrId,\n      record: record,\n      validation_result: 'FAILED',\n      validation_errors: errors,\n      drift_detected: hasDrift,\n      drift_details: driftDetected,\n      action: 'Quarantined',\n      timestamp: ts\n    });\n  }\n}\n\nreturn {\n  json: {\n    stage: 'Schema Validation & Drift Detection',\n    timestamp: new Date().toISOString(),\n    records_processed: records.length,\n    results: results,\n    summary: {\n      passed: results.filter(r => r.validation_result === 'PASSED').length,\n      quarantined: results.filter(r => r.validation_result === 'FAILED').length,\n      drift_detected: results.filter(r => r.drift_detected).length\n    },\n    db_state: {\n      staging_count: db.staging.flights_raw.length,\n      gold_v1_count: db.gold.flights_pricing_v1.length,\n      quarantine_count: db.ops.quarantine.length\n    }\n  }\n};"
      },
      "id": "validate-and-detect-drift",
      "name": "Validate & Detect Schema Drift",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Check if drift was detected and trigger agent analysis\n// Fix: Ensure staticData.db exists before accessing\n\nif (typeof $workflow === 'undefined' || !$workflow.staticData) {\n  $workflow = { staticData: {} };\n}\n\nif (!$workflow.staticData.db) {\n  $workflow.staticData.db = {\n    staging: { flights_raw: [] },\n    gold: { flights_pricing_v1: [], flights_pricing_v2: [] },\n    ops: { quarantine: [] },\n    featureFlags: { flights_pricing_read_compat: false },\n    compatView: null,\n    initialized: true\n  };\n}\n\nconst db = $workflow.staticData.db;\nconst results = $input.item.json.results || [];\nconst summary = $input.item.json.summary || {};\n\n// Check if any records had drift detected\nconst driftRecords = results.filter(r => r.drift_detected);\n\nif (driftRecords.length === 0) {\n  // No drift detected, just return success\n  return {\n    json: {\n      ...$input.item.json,\n      agent_analysis: false,\n      message: 'No schema drift detected. All records processed successfully.'\n    }\n  };\n}\n\n// Get latest quarantine item for analysis\nconst quarantine = db.ops.quarantine;\nif (quarantine.length === 0) {\n  return {\n    json: {\n      ...$input.item.json,\n      agent_analysis: false\n    }\n  };\n}\n\nconst latest = quarantine[quarantine.length - 1];\nconst sample = JSON.parse(latest.sample);\n\n// Analyze and propose compatibility view\nconst suggestions = [];\n\nif (latest.reason.includes('fare_usd') && (latest.reason.includes('string') || latest.reason.includes('type'))) {\n  suggestions.push({\n    issue: 'fare_usd type mismatch',\n    solution: 'CAST with tolerance: TRY_CAST(fare_usd AS DOUBLE) AS fare_usd',\n    sql_fragment: 'TRY_CAST(fare_usd AS DOUBLE) AS fare_usd'\n  });\n}\n\n// Check for additive columns\nconst additiveCols = latest.drift_detected ? Object.keys(sample).filter(k => !['flight_id', 'origin', 'destination', 'depart_ts', 'cabin', 'fare_usd', 'carrier_code', 'currency', 'taxes_usd'].includes(k)) : [];\n\nif (additiveCols.length > 0) {\n  additiveCols.forEach(col => {\n    suggestions.push({\n      issue: `Additive column: ${col}`,\n      solution: `Add nullable column: CAST(NULL AS VARCHAR) AS ${col}`,\n      sql_fragment: `CAST(NULL AS VARCHAR) AS ${col}`\n    });\n  });\n}\n\n// Build compatibility view SQL\nconst compatViewSQL = `CREATE OR REPLACE VIEW gold.flights_pricing_compat AS\nSELECT\n  flight_id, origin, destination, depart_ts, cabin,\n  /* cast with tolerance */ TRY_CAST(fare_usd AS DOUBLE) AS fare_usd,\n  carrier_code, currency, taxes_usd,\n  /* additive nullable columns */ ${additiveCols.map(col => `CAST(NULL AS VARCHAR) AS ${col}`).join(', ')}\nFROM gold.flights_pricing_v1;`;\n\n// Store compat view\nif (!db.compatView) {\n  db.compatView = compatViewSQL;\n}\n\nreturn {\n  json: {\n    ...$input.item.json,\n    agent_analysis: true,\n    stage: 'Agent Analysis & Patch Proposal',\n    timestamp: new Date().toISOString(),\n    quarantine_analysis: {\n      correlation_id: latest.correlation_id,\n      reason: latest.reason,\n      sample: sample,\n      drift_detected: latest.drift_detected\n    },\n    agent_suggestions: suggestions,\n    proposed_compat_view: compatViewSQL,\n    pr_file: 'PR_flights_pricing_compat.sql',\n    recommendation: 'Low-risk compat view ready; enable via feature flag for readers'\n  }\n};"
      },
      "id": "agent-analysis",
      "name": "Agent: Analyze Drift & Propose Patch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  success: true,\n  timestamp: $json.timestamp,\n  records_processed: $json.records_processed,\n  summary: $json.summary,\n  validation_results: $json.results,\n  agent_analysis: $json.agent_analysis || false,\n  agent_suggestions: $json.agent_suggestions || [],\n  db_state: $json.db_state,\n  message: $json.summary?.quarantined > 0 ? 'Some records quarantined due to schema drift. Check agent_analysis for recommendations.' : 'All records processed successfully.'\n}, null, 2) }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1120, 300]
    }
  ],
  "connections": {
    "Webhook: Ingest Flight Data": {
      "main": [
        [
          {
            "node": "Initialize & Parse Incoming Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize & Parse Incoming Data": {
      "main": [
        [
          {
            "node": "Validate & Detect Schema Drift",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Detect Schema Drift": {
      "main": [
        [
          {
            "node": "Agent: Analyze Drift & Propose Patch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent: Analyze Drift & Propose Patch": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {},
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-27T00:00:00.000Z",
  "versionId": "1"
}
